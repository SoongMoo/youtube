brew services start mongodb-community@6.0

mongosh
use admin
use admin
db.createUser({user:'rhee',pwd:'1234',roles:['root']})


--mongodb 재시작
brew services restart mongodb-community@6.0

---mongosh 계정으로 접속
mongosh admin -u rhee -p 1234


new Date()

db.movies.stats()

function factorial(n) { if (n <= 1) return 1; return n * factorial(n - 1); }
factorial(5)


use video

movie={"title":"star wars","director":"george" ,"year":1997}
db.movies.insertOne(movie)
db.movies.updateOne({ "title": "star wars" }, { $set: { reviews: [] } })
db.movies.find()
[
  {
    _id: ObjectId('657947749b982be1bf6c2ccc'),
    title: 'star wars',
    director: 'george',
    year: 1997,
    reviews: []
  }
]

db.movies.insertOne({"title":"star wars","director":"george" ,"year":1997})
db.movies.updateOne({ "title": "star wars" }, { $set: { "title": "star wars- IV" } })
db.movies.insertMany([{ "id": 0, "title": "Top Gun" }, { "id": 1, "title": "백투더 퓨처" }, { "id": 2, "title": "Gremnlins" }, { "id": 4, "title": "Aliens" }])
db.movies.insertMany([{ "id": 5, "title": "Top Gun" }, { "id": 6, "title": "백투더 퓨처" }, { "id": 6, "title": "Gremnlins" }, { "id": 7, "title": "Aliens" }])

db.movies.find().pretty()
db.movies.findOne()

db.movies.drop()
db.movies.insertMany([{ "_id": 5, "title": "Top Gun" }, { "_id": 4, "title": "백투더 퓨처" }, { "_id": 6, "title": "Gremnlins" }, { "_id": 7, "title": "Aliens" }])

db.movies.find()
db.movies.deleteOne({"_id":4})
 
db.movies.insertOne({
 "_id" : ObjectId("4b2b9f67a1f631733d917a7a"),
 "name" : "joe",
 "friends" : 32,
 "enemies" : 2
})

///// 아래 처럼 서브 도큐먼트로 변경
{
  _id: ObjectId('4b2b9f67a1f631733d917a7a'),
  relationships: { friends: 32, enemies: 2 },
  userNane: 'joe'
}
////

var joe = db.movies.findOne({"name":"joe"})
joe.relationships = {"friends":joe.friends, "enemies":joe.enemies };
joe.userNane = joe.name
delete joe.friends;
delete joe.enemies;

delete joe.name;

db.movies.replaceOne({"name":"joe"}, joe)

db.people

db.people.insertMany([{
 "_id" : ObjectId("4b2b9f67a1f631733d917a7a"),
 "name" : "joe",
 "age" : 65
},
{
 "_id" : ObjectId("4b2b9f67a1f631733d917a7b"),
 "name" : "joe",
 "age" : 20
},
{
 "_id" : ObjectId("4b2b9f67a1f631733d917a7c"),
 "name" : "joe",
 "age" : 49
}])

db.people.find()

joe  = db.people.findOne({
 "name" : "joe",
 "age" : 20
})
joe.age++
db.people.replaceOne({"name":"joe"}, joe)   --- MongoServerError: After applying the update
db.people.replaceOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7b")}, joe)
///
db.people.find()
[
  { _id: ObjectId('4b2b9f67a1f631733d917a7a'), name: 'joe', age: 65 },
  { _id: ObjectId('4b2b9f67a1f631733d917a7b'), name: 'joe', age: 21 },
  { _id: ObjectId('4b2b9f67a1f631733d917a7c'), name: 'joe', age: 49 }
]
///


db.analyties.insertOne({
 "_id" : ObjectId("4b2b9f67a1f631733d917a7a"),
 "url" : "wwww.example.com",
 "pageViews" : 52
})
///1증가
db.analyties.updateOne({"url" : "wwww.example.com"},
  {"$inc" : {"pageViews" : 1}
})

db.users.insertMany([
  { "_id": ObjectId('4b2b9f67a1f631733d917a7a'), "name": 'joe', "age": 65 , "sex" : "male", "location" : "wisconsin"},
  { "_id": ObjectId('4b2b9f67a1f631733d917a7b'), "name": 'joe', "age": 21 , "sex" : "male", "location" : "wisconsin"},
  { "_id": ObjectId('4b2b9f67a1f631733d917a7c'), "name": 'joe', "age": 49 , "sex" : "male", "location" : "wisconsin"}
])

db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a')},
  {"$set" : {"favorite book" : "war and peace"}})


db.users.updateOne({"name": 'joe'},
  {"$set" : {"favorite book" : "Green Eggs and Ham"}})

db.users.updateOne({"name": 'joe'},
  {"$set" : {"favorite book" : 1}})


db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a')},
  {"$set" : {"favorite book" : "War and Peace"}})

db.users.updateOne({"name": 'joe'},
  {"$set" : {"favorite book" : "Green Eggs and Ham"}})

db.users.updateOne({"name": 'joe'},
  {"$set" : {"favorite book" : ["Green Eggs and Ham","War and Peace","Car's Cadle"]}})


// "favorite book" 삭제
db.users.updateOne({"name": 'joe'},
  {"$unset" : {"favorite book" : 1 }})
키를 추가, 삭제, 변경할 때는 항상 $제한자를 사용해야 한다.

// 증가 및 감소
db.games.insertOne({"game":"pinball", "user" : "joe"})

// 도큐먼트에 키 추가
db.games.updateOne({"game":"pinball", "user" : "joe"},
{"$inc": {"score" : 50}})

// 갱신
db.games.updateOne({"game":"pinball", "user" : "joe"},
{"$inc": {"score" : 100000}})
//// 기존에 있던 숫자형 값을 갖는 "score"키에 서버가 10000을 더한다.
[
  {
    _id: ObjectId('657a6c86add257455351ede9'),
    game: 'pinball',
    user: 'joe',
    score: 100050
  }
]
///

$inc는 int , long, double, decimal타입값에만 사용할 수 있다. 키 값은 무조건 숫자여야 한다,
null, 불리언, 문자열로 나타낸 숫자와 같이 여러 언어에서 숫자로 자종 변환되는 데이터형의 값에서는 사용할 수 없다.

배열 연산자
db.blog.posts.insertOne(
{ "_id": ObjectId('657a6c86add257455351ede9'),
  "title" : "A blog post",
  "content" : "...."}
)
db.blog.posts.findOne()

db.blog.posts.updateOne(
{ "title" : "A blog post"},
{"$push" : { "contents" : 
  {"name" : "joe", "email" : "joe@example.com", "content" : "nice post."}}})

/// 댓글 추가
db.blog.posts.updateOne(
{ "title" : "A blog post"},
{"$push" : { "contents" : 
  {"name" : "bob", "email" : "bob@example.com", "content" : "good post."}}})

// $each를 사용하여 한번에 여러개의 값을 추가할 수 있다.
db.movies.findOne({"userNane": 'joe'})
db.movies.updateOne({"userNane": 'joe'},
  {"$set" : {"top10" : ["Green Eggs and Ham"]}}) /// 꼭 배열이어야 함

db.movies.updateOne({ "userNane": 'joe'},
  {"$push" : { "top10" : {"$each" : ["Nightmare on Elm Street", "Saw"],  
                        "$slice" : - 10 }}})
// -10은 배열의 요소의 갯수가 10보다 작으면 모든 요소를 유지 하고 10요소보다 크면 10까지만 유지
// $slice는 도큐먼트 내에 큐를 생성하는 데 사용할 수 있다.

db.movies.findOne({"userNane": 'joe'})
db.movies.updateOne({"userNane": 'joe'},
  {"$set" : {"top10" : []}})

db.movies.updateOne({ "userNane": 'joe'},
  {"$push" : { "top10" : {"$each" : [{ "name" : "Nightmare on Elm Street", "rating" : 6.6 },
                                     { "name" : "Saw", "rating" : 4.3 }],  
                          "$slice" : - 10 ,
                          "$sort" : {"rating":-1}}}})
$slice와 $sort를 사용하려면 $each와 같이 사용해야 한다.

// 배열을 집합으로 사용
//특정 한 값이 배열에 존재하지 않았을 때... 배열을 집합처럼 처리할 때
db.movies.updateOne({ "top10": {"$ne" : "Richie"}},
  {"$push" : {"top10" : {"name" : "Richie", "rating" : 5.3  }}})

db.users.findOne( {"_id": ObjectId('4b2b9f67a1f631733d917a7a') } )
db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a') },
  {"$set" : {"email" : ["joe@example.com", "joe@gmail.com" , "joe@yahoo.com" ]}}) 
db.users.findOne( {"_id": ObjectId('4b2b9f67a1f631733d917a7a') } )

/// $addToSet을 사용하면 중복을 피할 수 있다.
db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a') },
  {"$addToSet" : {"email" : "joe@gmail.com" }}) 
db.users.findOne( {"_id": ObjectId('4b2b9f67a1f631733d917a7a') } )


db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a') },
  {"$addToSet" : {"email" : "joe@hotmail.com" }}) 
db.users.findOne( {"_id": ObjectId('4b2b9f67a1f631733d917a7a') } )

/// 고유의 값을 여러개를 추가하려면 $addToSet과 $each를 결합해야 한다.
db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a') },
  {"$addToSet" : {"email" : {"$each" : ["joe@php.net", "joe@example.com", "joe@python.org"]
}}}) 

/// 배열에서 요소 제거
db.lists.insertOne({"todo": ["dishes", "laundry", "dry clearing"]})
db.lists.updateOne({},{"$pull" : {"todo": "laundry"} })
db.lists.find()
/// $pull은 도큐먼트에서 조건과 일치하는 요소를 모두  제거 한다. 스칼라값은 변경할 수 없다.


// 배열의 위치 기반 변경
db.blog.insertOne(
{ "_id": ObjectId('657a6c86add257455351ede9'),
  "title" : "A blog post",
  "content" : "....",
  "comments" : [
              {
                "comment" : "good post",
                "auther" : "John",
                "votes" : 0
              },
              {
                "comment" : "i thougnt it was too short",
                "auther" : "Clare",
                "votes" : 3
              },
              {
                "comment" : "free watches",
                "auther" : "Alice",
                "votes" : -5
              },
              {
                "comment" : "vacation getways",
                "auther" : "Lynn",
                "votes" : -7
              }
  ]
}
)
db.blog.findOne()

/// 첫번째 댓글의 투표수를 증가시키기
db.blog.updateOne({ "_id": ObjectId('657a6c86add257455351ede9')},
                  {"$inc" : { "comments.0.votes" : 1}})


// 몇번째 요소를 변경할 지 알 수 없는 경우 일치하는 ㅇ배열 요소 및 요소의 위치를 알아내기 위해 $를 사용 할 수 있다.
db.blog.updateOne({ "comments.auther": "John"},
                  {"$set" : { "comments.$.auther" : "Jim"}})
두개 이상의 댓글이 있는 경우에는 첫번째만 변경됩

/// 배열 필터를 이용한 갱신 -- 특정 조건에 맞는 배열 요소를 갱신하기 위해서는 arrayFilters를 사용한다,
db.blog.updateOne({ "comments.auther": "Jim"},
                  {"$set" : { "comments.$[elem].hidden" : true}},
                  {
                  arrayFilters : [{"elem.votes": {$lte : 2}}]
                  })
//// 각 일치요소에 대한 식별자로 elem을 정의 elem이 식별한 댓글 투표값이 2이하($lte)면 hidden필드 추가하고 값은 true로 설정
///
video> db.blog.find()
[
  {
    _id: ObjectId('657a6c86add257455351ede9'),
    title: 'A blog post',
    content: '....',
    comments: [
      { comment: 'good post', auther: 'Jim', votes: 1, hidden: true },
      {
        comment: 'i thougnt it was too short',
        auther: 'Clare',
        votes: 3
      },
      {
        comment: 'free watches',
        auther: 'Alice',
        votes: -5,
        hidden: true
      },
      {
        comment: 'vacation getways',
        auther: 'Lynn',
        votes: -7,
        hidden: true
      }
    ]
  }
]
///


//// 갱신 입력
갱신 조건에 맞는 도큐먼트가 존재하지 않을 때는 쿼리 도큐먼트와 갱신 도큐먼트를 합쳐서 새로운 도큐먼트를 생성한다.
조건에 맞는 도큐먼트가 발견되면 일반적인 갱신이 수행한다.
var blog = db.analyties.findOne({ url: "/blog" });

if (blog) {
  // URL이 이미 존재하는 경우
  db.analyties.updateOne(
    { url: "/blog" },
    { $inc: { pageViews: 1 } }
  );
} else {
  // URL이 존재하지 않는 경우
  db.analyties.insertOne({ url: "/blog", pageViews: 1 });
}
//// 아래 처럼 작성하면 편하게 작성할 수 있다.
db.analyties.updateOne( { "url" : "/blog1"} , {"$inc" : {"pageViews" : 1}}, {"upsert" : true})

db.analyties.updateOne({"pageViews" : 3},{"$inc": {"pageViews":1}},{"upsert":true})
//pageViews가 3인 새로운 도큐먼트를 만들고 3만큼 증가시켜 pageViews는 4가 된다.
//일치 하지않으면 실행되지 않는다.

// 다중 도큐먼트 갱신
db.users.insertMany([{"birthday" : "10/13/1978"},
{"birthday" : "10/13/1978"},
{"birthday" : "10/13/1978"}])

db.users.updateMany({"birthday" : "10/13/1978"},
{"$set":{"gift":"Happy Birthday!"}})


> db.people.find({"age":65})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65 }

> db.people.find({"name":"joe"})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49 }

> db.people.find({"name":"joe", "age" : 20})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }

name과 age만 반환
> db.people.find({ }, {"name":1, "age":1})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49 }

age만 반환
> db.people.find({ }, { "age":1})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "age" : 65 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "age" : 20 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "age" : 49 }

_id는 반환하지 않아도 항상 반환

# name 만 빼고 모두
> db.people.find({ }, { "name":0})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "age" : 65 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "age" : 20 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "age" : 49 }

_id제외하고 name만
> db.people.find({ }, { "name":1, "_id":0})
{ "name" : "joe" }
{ "name" : "joe" }
{ "name" : "joe" }

# 쿼리 조건절
<, <=, >, >=에 해당하는 비교 연산자는 각각 "$lt" ,"$lte", "$gt", "$gte" : 특정 범위 내 값을 쿼리할 수 있다.
select * from people where age >= 18 and age <= 30
> db.people.find({"age" : {"$gte" : 18 , "$lte" : 30 }})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }


> db.users.updateMany({"name" : "joe"}, {"$set" : {"birthday" : "10/13/1978"}})
{ "acknowledged" : true, "matchedCount" : 3, "modifiedCount" : 3 }

> db.users.find()
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }

> start = new Date("01/01/2007")
ISODate("2006-12-31T15:00:00Z")
> db.users.find({"birthday":{ "$lt" : start}})
날짜는 1/1000초 단위로 저장되므로 정확히 일치하는 조건이 없어 결과가 나오지 않는다

> db.users.find({"birthday":{ "$ne" : start}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }
$ne는 모든 자료형에 사용이 가능한다.

### OR쿼리
 몽고 DB는 OR쿼리에 두가지  : "$in"은 하나의 키를 다양한(여러개) 값과 비교 
                            "$or"는 여러 키를 주어진 값과 비교하는 쿼리

> db.users.find({"age":{ "$in" : [20, 40, 65]}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }

> db.users.updateOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7b")}, {"$set" : {"name" : "rhee"}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

> db.users.find({"name":{ "$in" : [20, 40, "rhee"]}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "rhee", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }

### $nin 은 not in을 의미한다.
> db.users.find({"name":{ "$nin" : [20, 40, "rhee"]}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }

### 여러개 의 키를 비교
select * from users where name = 'rhee' or birth = '10/13/1978'
> db.users.find({"$or" : [{"name" :{"rhee"}, {"birthday" : "10/13/1978"}]})

select * from users where name in (20, 40, 'rhee') or birthday = '10/13/1978'
> db.users.find({"$or" : [{"name" :{ "$nin" : [20, 40, "rhee"]} }, {"birthday" : "10/13/1978"}]})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "rhee", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }


> db.users.updateOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7a")}, {"$set" : {"id_num" : 1}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
> db.users.updateOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7b")}, {"$set" : {"id_num" : 6}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
> db.users.updateOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7c")}, {"$set" : {"id_num" : 15}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
> db.users.find({"id_num" : {"$mod":[5, 1]}})

###나머지 연산 
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978", "id_num" : 1 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "rhee", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978", "id_num" : 6 }

#### $not
메타조건 절이며 어더한 조건에도 적용할 수 있다.    
> db.users.find({"id_num" : { "$not" : {"$mod":[5, 1]}}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978", "id_num" : 15 }

### 형 특정 쿼리
### null
db.c.insertMany([
  { "_id": ObjectId('4b2b9f67a1f631733d917a7a'), "y": null},
  { "_id": ObjectId('4b2b9f67a1f631733d917a7b'), "y": 1, },
  { "_id": ObjectId('4b2b9f67a1f631733d917a7c'), "y": 2, }
])
> db.c.find()
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "y" : null }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "y" : 1 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "y" : 2 }

> db.c.find({"y" : null})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "y" : null }
"y"키가 null인 도큐먼트를 쿼리한  결과이다.

하지만 null은 '존재하지 않음'과도 일치한다. 그러므로 키가 null인 값을 쿼리하면 해당 키를 갖지 않는 도큐먼트도 반환한다.
> db.c.find({"z" : null})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "y" : null }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "y" : 1 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "y" : 2 }

# 키가 없는 경우를 제외하려면 다음과 같이  "$exists"조건절을 사용하면 된다.
> db.c.find({"z" : {"$eq" : null , "$exists" : true}})

### 배열에 쿠리하기
> db.food.insertOne({"fruit": ["apple","banana","peach"]})
{
        "acknowledged" : true,
        "insertedId" : ObjectId("65829bfcc6cb4f06e7cd2e87")
}
> db.food.find({"fruit":"banana"})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }

$all연산자
2개이상의 요소가 일치하는 배열을 찾을 때
> db.food.insertOne({"fruit": ["apple","kumpuat","orange"]})
> db.food.insertOne({"fruit": ["cherry","banana","apple"]})
> db.food.find()
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }
{ "_id" : ObjectId("65829d39c6cb4f06e7cd2e88"), "fruit" : [ "apple", "kumpuat", "orange" ] }
{ "_id" : ObjectId("65829d47c6cb4f06e7cd2e89"), "fruit" : [ "cherry", "banana", "apple" ] }
> db.food.find({"fruit" : {"$all" : ["apple","banana"]}})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }
{ "_id" : ObjectId("65829d47c6cb4f06e7cd2e89"), "fruit" : [ "cherry", "banana", "apple" ] }

> db.food.find({"fruit": ["apple","banana","peach"]})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }

> db.food.find({"fruit": ["apple","banana"]})
일치 하는 것이 없다.
> db.food.find({"fruit": ["banana","apple","peach"]})
마찬가지
> db.food.find({"fruit": "peach"})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }

index가 2인 요소가 peach인것만
> db.food.find({"fruit.2": "peach"})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }


$size는 특정 크기의 배열을 쿼리하는 유용한 조건절
> db.food.find({"fruit": {"$size" : 3}})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }
{ "_id" : ObjectId("65829d39c6cb4f06e7cd2e88"), "fruit" : [ "apple", "kumpuat", "orange" ] }
{ "_id" : ObjectId("65829d47c6cb4f06e7cd2e89"), "fruit" : [ "cherry", "banana", "apple" ] }

배열갱신
> var criteria = {"_id" : ObjectId("65829bfcc6cb4f06e7cd2e87")}
> db.food.update(criteria, {"$push" : {"fruit" : "strawberry"}}  )
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })

> db.food.update(criteria, {"$push" : {"fruit" : "strawberry"}, "$inc" : {"size" : 1}}  )
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
> db.food.find()
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach", "strawberry", "strawberry" ], "size" : 1 }
{ "_id" : ObjectId("65829d39c6cb4f06e7cd2e88"), "fruit" : [ "apple", "kumpuat", "orange" ] }
{ "_id" : ObjectId("65829d47c6cb4f06e7cd2e89"), "fruit" : [ "cherry", "banana", "apple" ] }

> db.food.find({"size" : {"$gte" : 1}}))
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach", "strawberry", "strawberry" ], "size" : 1 }

$slice연산자
find의 두 번째 매개변수에는 반환받을 키를 지정한다.
$slice연산자를 사용해서 배열 요소의 부분 집합을 반환받을 수 있다.

# comments를 2만 가지고 오기
> db.blog.findOne({"_id" : ObjectId("657a6c86add257455351ede9")}, {"comments" : {"$slice" : 2}})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "title" : "A blog post",
        "content" : "....",
        "comments" : [
                {
                        "comment" : "good post",
                        "auther" : "John",
                        "votes" : 0
                },
                {
                        "comment" : "i thougnt it was too short",
                        "auther" : "Clare",
                        "votes" : 3
                }
        ]
}

# 밑에서 2개만 가지고 오기
> db.blog.findOne({"_id" : ObjectId("657a6c86add257455351ede9")}, {"comments" : {"$slice" : -2}})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "title" : "A blog post",
        "content" : "....",
        "comments" : [
                {
                        "comment" : "free watches",
                        "auther" : "Alice",
                        "votes" : -5
                },
                {
                        "comment" : "vacation getways",
                        "auther" : "Lynn",
                        "votes" : -7
                }
        ]
}

# 2번까지 건너 뛰고 2개 가져오기
> db.blog.findOne({"_id" : ObjectId("657a6c86add257455351ede9")}, {"comments" : {"$slice" : [2, 2]}})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "title" : "A blog post",
        "content" : "....",
        "comments" : [
                {
                        "comment" : "free watches",
                        "auther" : "Alice",
                        "votes" : -5
                },
                {
                        "comment" : "vacation getways",
                        "auther" : "Lynn",
                        "votes" : -7
                }
        ]
}

#마지막 댓글 가져온다.
> db.blog.findOne({"_id" : ObjectId("657a6c86add257455351ede9")}, {"comments" : {"$slice" : -1}})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "title" : "A blog post",
        "content" : "....",
        "comments" : [
                {
                        "comment" : "vacation getways",
                        "auther" : "Lynn",
                        "votes" : -7
                }
        ]
}

#comments의 auther가 John의 댓글을 하나만
> db.blog.findOne({"comments.auther" :  "John" }, {"comments.$" : 1})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "comments" : [
                {
                        "comment" : "good post",
                        "auther" : "John",
                        "votes" : 0
                }
        ]
}

> db.collectionName.insertOne({ 'x': 5 });
> db.collectionName.insertOne({ 'x': 15 });
> db.collectionName.insertOne({ 'x': 25 });
> db.collectionName.insertOne({ 'x': [5, 25]});
> db.collectionName.find();
{ "_id" : ObjectId("6583e9e038416d4181fc58b1"), "x" : 5 }
{ "_id" : ObjectId("6583e9e538416d4181fc58b2"), "x" : 15 }
{ "_id" : ObjectId("6583e9eb38416d4181fc58b3"), "x" : 25 }
{ "_id" : ObjectId("6583e9ef38416d4181fc58b4"), "x" : [ 5, 25 ] }

> db.collectionName.find({"x" : {"$gt" : 10, "$lt" : 20}});
{ "_id" : ObjectId("6583e9e538416d4181fc58b2"), "x" : 15 }
{ "_id" : ObjectId("6583e9ef38416d4181fc58b4"), "x" : [ 5, 25 ] }
5와 25는 둘 다 10과 20사이는 아니지만 25는 첫번째 절과 일치하고 (10보다 크다) 5는 두 번째 결과와 일치하기 때문(20보다 작다)에 반환된다.
이 방법은 배열에 대한 범위 쿼리가 슬모없어진다.
범위가 다중요소 배열과 일치하기 때문이다.

> db.collectionName.find({"x" : {"$elemMatch" : {"$gt" : 10, "$lt" : 20}}});
결과없음
{ "x" : 15 }는 배열이 아니므로 쿼리와 일티 하지 않음

> db.collectionName.insertOne({ 'x': [13, 18]});
> db.collectionName.find({"x" : {"$elemMatch" : {"$gt" : 10, "$lt" : 20}}});
{ "_id" : ObjectId("6583eca738416d4181fc58b5"), "x" : [ 13, 18 ] }
$elemMatch은 배열 요소에 대한 범위 쿼리에 유용



> db.people.insertOne({"name" : {"first" : "Joe" , "last" : "Schmoe"}, "age" : 45})
> db.people.find({"name" : {"first" : "Joe", "last" : "Schmoe"}})
{ "_id" : ObjectId("6583f1f738416d4181fc58b6"), "name" : { "first" : "Joe", "last" : "Schmoe" }, "age" : 45 }

내장 도큐먼트 쿼리를 할때는 가능하다면 특정키로 쿼리하는 방법이 좋다.
> db.people.find({"name.first" : "Joe", "name.last" : "Schmoe"})
{ "_id" : ObjectId("6583f1f738416d4181fc58b6"), "name" : { "first" : "Joe", "last" : "Schmoe" }, "age" : 45 }


> db.blog.find({"comments" : {"auther" : "Clare", "votes" : {"$lte" : 3}}})
결과가 없다
> db.blog.find({"comments.auther" : "Clare", "comments.votes" : {"$lte" : 3}})
{ "_id" : ObjectId("657a6c86add257455351ede9"), "title" : "A blog post", "content" : "....", "comments" : [ { "comment" : "good post", "auther" : "John", "votes" : 0 }, { "comment" : "i thougnt it was too short", "auther" : "Clare", "votes" : 3 }, { "comment" : "free watches", "auther" : "Alice", "votes" : -5 }, { "comment" : "vacation getways", "auther" : "Lynn", "votes" : -7 } ] }
> db.blog.find({"comments" : {"$elemMatch" : {"auther" : "John", "votes" : {"$lte": 3} }}})
{ "_id" : ObjectId("657a6c86add257455351ede9"), "title" : "A blog post", "content" : "....", "comments" : [ { "comment" : "good post", "auther" : "John", "votes" : 0 }, { "comment" : "i thougnt it was too short", "auther" : "Clare", "votes" : 3 }, { "comment" : "free watches", "auther" : "Alice", "votes" : -5 }, { "comment" : "vacation getways", "auther" : "Lynn", "votes" : -7 } ] }
>

# $where쿼리













