brew services start mongodb-community@6.0

mongosh
use admin
use admin
db.createUser({user:'rhee',pwd:'1234',roles:['root']})


--mongodb 재시작
brew services restart mongodb-community@6.0

---mongosh 계정으로 접속
mongosh admin -u rhee -p 1234
mongo admin -u rhee -p 1234

new Date()

db.movies.stats()

function factorial(n) { if (n <= 1) return 1; return n * factorial(n - 1); }
factorial(5)


use video

movie={"title":"star wars","director":"george" ,"year":1997}
db.movies.insertOne(movie)
db.movies.updateOne({ "title": "star wars" }, { $set: { reviews: [] } })
db.movies.find()
[
  {
    _id: ObjectId('657947749b982be1bf6c2ccc'),
    title: 'star wars',
    director: 'george',
    year: 1997,
    reviews: []
  }
]

db.movies.insertOne({"title":"star wars","director":"george" ,"year":1997})
db.movies.updateOne({ "title": "star wars" }, { $set: { "title": "star wars- IV" } })
db.movies.insertMany([{ "id": 0, "title": "Top Gun" }, { "id": 1, "title": "백투더 퓨처" }, { "id": 2, "title": "Gremnlins" }, { "id": 4, "title": "Aliens" }])
db.movies.insertMany([{ "id": 5, "title": "Top Gun" }, { "id": 6, "title": "백투더 퓨처" }, { "id": 6, "title": "Gremnlins" }, { "id": 7, "title": "Aliens" }])

db.movies.find().pretty()
db.movies.findOne()

db.movies.drop()
db.movies.insertMany([{ "_id": 5, "title": "Top Gun" }, { "_id": 4, "title": "백투더 퓨처" }, { "_id": 6, "title": "Gremnlins" }, { "_id": 7, "title": "Aliens" }])

db.movies.find()
db.movies.deleteOne({"_id":4})
 
db.movies.insertOne({
 "_id" : ObjectId("4b2b9f67a1f631733d917a7a"),
 "name" : "joe",
 "friends" : 32,
 "enemies" : 2
})

///// 아래 처럼 서브 도큐먼트로 변경
{
  _id: ObjectId('4b2b9f67a1f631733d917a7a'),
  relationships: { friends: 32, enemies: 2 },
  userNane: 'joe'
}
////

var joe = db.movies.findOne({"name":"joe"})
joe.relationships = {"friends":joe.friends, "enemies":joe.enemies };
joe.userNane = joe.name
delete joe.friends;
delete joe.enemies;

delete joe.name;

db.movies.replaceOne({"name":"joe"}, joe)

db.people

db.people.insertMany([{
 "_id" : ObjectId("4b2b9f67a1f631733d917a7a"),
 "name" : "joe",
 "age" : 65
},
{
 "_id" : ObjectId("4b2b9f67a1f631733d917a7b"),
 "name" : "joe",
 "age" : 20
},
{
 "_id" : ObjectId("4b2b9f67a1f631733d917a7c"),
 "name" : "joe",
 "age" : 49
}])

db.people.find()

joe  = db.people.findOne({
 "name" : "joe",
 "age" : 20
})
joe.age++
db.people.replaceOne({"name":"joe"}, joe)   --- MongoServerError: After applying the update
db.people.replaceOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7b")}, joe)
///
db.people.find()
[
  { _id: ObjectId('4b2b9f67a1f631733d917a7a'), name: 'joe', age: 65 },
  { _id: ObjectId('4b2b9f67a1f631733d917a7b'), name: 'joe', age: 21 },
  { _id: ObjectId('4b2b9f67a1f631733d917a7c'), name: 'joe', age: 49 }
]
///


db.analyties.insertOne({
 "_id" : ObjectId("4b2b9f67a1f631733d917a7a"),
 "url" : "wwww.example.com",
 "pageViews" : 52
})
///1증가
db.analyties.updateOne({"url" : "wwww.example.com"},
  {"$inc" : {"pageViews" : 1}
})

db.users.insertMany([
  { "_id": ObjectId('4b2b9f67a1f631733d917a7a'), "name": 'joe', "age": 65 , "sex" : "male", "location" : "wisconsin"},
  { "_id": ObjectId('4b2b9f67a1f631733d917a7b'), "name": 'joe', "age": 21 , "sex" : "male", "location" : "wisconsin"},
  { "_id": ObjectId('4b2b9f67a1f631733d917a7c'), "name": 'joe', "age": 49 , "sex" : "male", "location" : "wisconsin"}
])

db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a')},
  {"$set" : {"favorite book" : "war and peace"}})


db.users.updateOne({"name": 'joe'},
  {"$set" : {"favorite book" : "Green Eggs and Ham"}})

db.users.updateOne({"name": 'joe'},
  {"$set" : {"favorite book" : 1}})


db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a')},
  {"$set" : {"favorite book" : "War and Peace"}})

db.users.updateOne({"name": 'joe'},
  {"$set" : {"favorite book" : "Green Eggs and Ham"}})

db.users.updateOne({"name": 'joe'},
  {"$set" : {"favorite book" : ["Green Eggs and Ham","War and Peace","Car's Cadle"]}})


// "favorite book" 삭제
db.users.updateOne({"name": 'joe'},
  {"$unset" : {"favorite book" : 1 }})
키를 추가, 삭제, 변경할 때는 항상 $제한자를 사용해야 한다.

// 증가 및 감소
db.games.insertOne({"game":"pinball", "user" : "joe"})

// 도큐먼트에 키 추가
db.games.updateOne({"game":"pinball", "user" : "joe"},
{"$inc": {"score" : 50}})

// 갱신
db.games.updateOne({"game":"pinball", "user" : "joe"},
{"$inc": {"score" : 100000}})
//// 기존에 있던 숫자형 값을 갖는 "score"키에 서버가 10000을 더한다.
[
  {
    _id: ObjectId('657a6c86add257455351ede9'),
    game: 'pinball',
    user: 'joe',
    score: 100050
  }
]
///

$inc는 int , long, double, decimal타입값에만 사용할 수 있다. 키 값은 무조건 숫자여야 한다,
null, 불리언, 문자열로 나타낸 숫자와 같이 여러 언어에서 숫자로 자종 변환되는 데이터형의 값에서는 사용할 수 없다.

배열 연산자
db.blog.posts.insertOne(
{ "_id": ObjectId('657a6c86add257455351ede9'),
  "title" : "A blog post",
  "content" : "...."}
)
db.blog.posts.findOne()

db.blog.posts.updateOne(
{ "title" : "A blog post"},
{"$push" : { "contents" : 
  {"name" : "joe", "email" : "joe@example.com", "content" : "nice post."}}})

/// 댓글 추가
db.blog.posts.updateOne(
{ "title" : "A blog post"},
{"$push" : { "contents" : 
  {"name" : "bob", "email" : "bob@example.com", "content" : "good post."}}})

// $each를 사용하여 한번에 여러개의 값을 추가할 수 있다.
db.movies.findOne({"userNane": 'joe'})
db.movies.updateOne({"userNane": 'joe'},
  {"$set" : {"top10" : ["Green Eggs and Ham"]}}) /// 꼭 배열이어야 함

db.movies.updateOne({ "userNane": 'joe'},
  {"$push" : { "top10" : {"$each" : ["Nightmare on Elm Street", "Saw"],  
                        "$slice" : - 10 }}})
// -10은 배열의 요소의 갯수가 10보다 작으면 모든 요소를 유지 하고 10요소보다 크면 10까지만 유지
// $slice는 도큐먼트 내에 큐를 생성하는 데 사용할 수 있다.

db.movies.findOne({"userNane": 'joe'})
db.movies.updateOne({"userNane": 'joe'},
  {"$set" : {"top10" : []}})

db.movies.updateOne({ "userNane": 'joe'},
  {"$push" : { "top10" : {"$each" : [{ "name" : "Nightmare on Elm Street", "rating" : 6.6 },
                                     { "name" : "Saw", "rating" : 4.3 }],  
                          "$slice" : - 10 ,
                          "$sort" : {"rating":-1}}}})
$slice와 $sort를 사용하려면 $each와 같이 사용해야 한다.

// 배열을 집합으로 사용
//특정 한 값이 배열에 존재하지 않았을 때... 배열을 집합처럼 처리할 때
db.movies.updateOne({ "top10": {"$ne" : "Richie"}},
  {"$push" : {"top10" : {"name" : "Richie", "rating" : 5.3  }}})

db.users.findOne( {"_id": ObjectId('4b2b9f67a1f631733d917a7a') } )
db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a') },
  {"$set" : {"email" : ["joe@example.com", "joe@gmail.com" , "joe@yahoo.com" ]}}) 
db.users.findOne( {"_id": ObjectId('4b2b9f67a1f631733d917a7a') } )

/// $addToSet을 사용하면 중복을 피할 수 있다.
db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a') },
  {"$addToSet" : {"email" : "joe@gmail.com" }}) 
db.users.findOne( {"_id": ObjectId('4b2b9f67a1f631733d917a7a') } )


db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a') },
  {"$addToSet" : {"email" : "joe@hotmail.com" }}) 
db.users.findOne( {"_id": ObjectId('4b2b9f67a1f631733d917a7a') } )

/// 고유의 값을 여러개를 추가하려면 $addToSet과 $each를 결합해야 한다.
db.users.updateOne({"_id": ObjectId('4b2b9f67a1f631733d917a7a') },
  {"$addToSet" : {"email" : {"$each" : ["joe@php.net", "joe@example.com", "joe@python.org"]
}}}) 

/// 배열에서 요소 제거
db.lists.insertOne({"todo": ["dishes", "laundry", "dry clearing"]})
db.lists.updateOne({},{"$pull" : {"todo": "laundry"} })
db.lists.find()
/// $pull은 도큐먼트에서 조건과 일치하는 요소를 모두  제거 한다. 스칼라값은 변경할 수 없다.


// 배열의 위치 기반 변경
db.blog.insertOne(
{ "_id": ObjectId('657a6c86add257455351ede9'),
  "title" : "A blog post",
  "content" : "....",
  "comments" : [
              {
                "comment" : "good post",
                "auther" : "John",
                "votes" : 0
              },
              {
                "comment" : "i thougnt it was too short",
                "auther" : "Clare",
                "votes" : 3
              },
              {
                "comment" : "free watches",
                "auther" : "Alice",
                "votes" : -5
              },
              {
                "comment" : "vacation getways",
                "auther" : "Lynn",
                "votes" : -7
              }
  ]
}
)
db.blog.findOne()

/// 첫번째 댓글의 투표수를 증가시키기
db.blog.updateOne({ "_id": ObjectId('657a6c86add257455351ede9')},
                  {"$inc" : { "comments.0.votes" : 1}})


// 몇번째 요소를 변경할 지 알 수 없는 경우 일치하는 ㅇ배열 요소 및 요소의 위치를 알아내기 위해 $를 사용 할 수 있다.
db.blog.updateOne({ "comments.auther": "John"},
                  {"$set" : { "comments.$.auther" : "Jim"}})
두개 이상의 댓글이 있는 경우에는 첫번째만 변경됩

/// 배열 필터를 이용한 갱신 -- 특정 조건에 맞는 배열 요소를 갱신하기 위해서는 arrayFilters를 사용한다,
db.blog.updateOne({ "comments.auther": "Jim"},
                  {"$set" : { "comments.$[elem].hidden" : true}},
                  {
                  arrayFilters : [{"elem.votes": {$lte : 2}}]
                  })
//// 각 일치요소에 대한 식별자로 elem을 정의 elem이 식별한 댓글 투표값이 2이하($lte)면 hidden필드 추가하고 값은 true로 설정
///
video> db.blog.find()
[
  {
    _id: ObjectId('657a6c86add257455351ede9'),
    title: 'A blog post',
    content: '....',
    comments: [
      { comment: 'good post', auther: 'Jim', votes: 1, hidden: true },
      {
        comment: 'i thougnt it was too short',
        auther: 'Clare',
        votes: 3
      },
      {
        comment: 'free watches',
        auther: 'Alice',
        votes: -5,
        hidden: true
      },
      {
        comment: 'vacation getways',
        auther: 'Lynn',
        votes: -7,
        hidden: true
      }
    ]
  }
]
///


//// 갱신 입력
갱신 조건에 맞는 도큐먼트가 존재하지 않을 때는 쿼리 도큐먼트와 갱신 도큐먼트를 합쳐서 새로운 도큐먼트를 생성한다.
조건에 맞는 도큐먼트가 발견되면 일반적인 갱신이 수행한다.
var blog = db.analyties.findOne({ url: "/blog" });

if (blog) {
  // URL이 이미 존재하는 경우
  db.analyties.updateOne(
    { url: "/blog" },
    { $inc: { pageViews: 1 } }
  );
} else {
  // URL이 존재하지 않는 경우
  db.analyties.insertOne({ url: "/blog", pageViews: 1 });
}
//// 아래 처럼 작성하면 편하게 작성할 수 있다.
db.analyties.updateOne( { "url" : "/blog1"} , {"$inc" : {"pageViews" : 1}}, {"upsert" : true})

db.analyties.updateOne({"pageViews" : 3},{"$inc": {"pageViews":1}},{"upsert":true})
//pageViews가 3인 새로운 도큐먼트를 만들고 3만큼 증가시켜 pageViews는 4가 된다.
//일치 하지않으면 실행되지 않는다.

// 다중 도큐먼트 갱신
db.users.insertMany([{"birthday" : "10/13/1978"},
{"birthday" : "10/13/1978"},
{"birthday" : "10/13/1978"}])

db.users.updateMany({"birthday" : "10/13/1978"},
{"$set":{"gift":"Happy Birthday!"}})


> db.people.find({"age":65})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65 }

> db.people.find({"name":"joe"})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49 }

> db.people.find({"name":"joe", "age" : 20})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }

name과 age만 반환
> db.people.find({ }, {"name":1, "age":1})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49 }

age만 반환
> db.people.find({ }, { "age":1})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "age" : 65 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "age" : 20 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "age" : 49 }

_id는 반환하지 않아도 항상 반환

# name 만 빼고 모두
> db.people.find({ }, { "name":0})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "age" : 65 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "age" : 20 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "age" : 49 }

_id제외하고 name만
> db.people.find({ }, { "name":1, "_id":0})
{ "name" : "joe" }
{ "name" : "joe" }
{ "name" : "joe" }

# 쿼리 조건절
<, <=, >, >=에 해당하는 비교 연산자는 각각 "$lt" ,"$lte", "$gt", "$gte" : 특정 범위 내 값을 쿼리할 수 있다.
select * from people where age >= 18 and age <= 30
> db.people.find({"age" : {"$gte" : 18 , "$lte" : 30 }})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }


> db.users.updateMany({"name" : "joe"}, {"$set" : {"birthday" : "10/13/1978"}})
{ "acknowledged" : true, "matchedCount" : 3, "modifiedCount" : 3 }

> db.users.find()
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }

> start = new Date("01/01/2007")
ISODate("2006-12-31T15:00:00Z")
> db.users.find({"birthday":{ "$lt" : start}})
날짜는 1/1000초 단위로 저장되므로 정확히 일치하는 조건이 없어 결과가 나오지 않는다

> db.users.find({"birthday":{ "$ne" : start}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }
$ne는 모든 자료형에 사용이 가능한다.

### OR쿼리
 몽고 DB는 OR쿼리에 두가지  : "$in"은 하나의 키를 다양한(여러개) 값과 비교 
                            "$or"는 여러 키를 주어진 값과 비교하는 쿼리

> db.users.find({"age":{ "$in" : [20, 40, 65]}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }

> db.users.updateOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7b")}, {"$set" : {"name" : "rhee"}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }

> db.users.find({"name":{ "$in" : [20, 40, "rhee"]}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "rhee", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }

### $nin 은 not in을 의미한다.
> db.users.find({"name":{ "$nin" : [20, 40, "rhee"]}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }

### 여러개 의 키를 비교
select * from users where name = 'rhee' or birth = '10/13/1978'
> db.users.find({"$or" : [{"name" :{"rhee"}, {"birthday" : "10/13/1978"}]})

select * from users where name in (20, 40, 'rhee') or birthday = '10/13/1978'
> db.users.find({"$or" : [{"name" :{ "$nin" : [20, 40, "rhee"]} }, {"birthday" : "10/13/1978"}]})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "rhee", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978" }


> db.users.updateOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7a")}, {"$set" : {"id_num" : 1}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
> db.users.updateOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7b")}, {"$set" : {"id_num" : 6}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
> db.users.updateOne({"_id" : ObjectId("4b2b9f67a1f631733d917a7c")}, {"$set" : {"id_num" : 15}})
{ "acknowledged" : true, "matchedCount" : 1, "modifiedCount" : 1 }
> db.users.find({"id_num" : {"$mod":[5, 1]}})

###나머지 연산 
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65, "sex" : "male", "location" : "wisconsin", "favorite book" : [ "Green Eggs and Ham", "War and Peace", "Car's Cadle" ], "birthday" : "10/13/1978", "id_num" : 1 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "rhee", "age" : 21, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978", "id_num" : 6 }

#### $not
메타조건 절이며 어더한 조건에도 적용할 수 있다.    
> db.users.find({"id_num" : { "$not" : {"$mod":[5, 1]}}})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49, "sex" : "male", "location" : "wisconsin", "birthday" : "10/13/1978", "id_num" : 15 }

### 형 특정 쿼리
### null
db.c.insertMany([
  { "_id": ObjectId('4b2b9f67a1f631733d917a7a'), "y": null},
  { "_id": ObjectId('4b2b9f67a1f631733d917a7b'), "y": 1, },
  { "_id": ObjectId('4b2b9f67a1f631733d917a7c'), "y": 2, }
])
> db.c.find()
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "y" : null }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "y" : 1 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "y" : 2 }

> db.c.find({"y" : null})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "y" : null }
"y"키가 null인 도큐먼트를 쿼리한  결과이다.

하지만 null은 '존재하지 않음'과도 일치한다. 그러므로 키가 null인 값을 쿼리하면 해당 키를 갖지 않는 도큐먼트도 반환한다.
> db.c.find({"z" : null})
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "y" : null }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "y" : 1 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "y" : 2 }

# 키가 없는 경우를 제외하려면 다음과 같이  "$exists"조건절을 사용하면 된다.
> db.c.find({"z" : {"$eq" : null , "$exists" : true}})

### 배열에 쿠리하기
> db.food.insertOne({"fruit": ["apple","banana","peach"]})
{
        "acknowledged" : true,
        "insertedId" : ObjectId("65829bfcc6cb4f06e7cd2e87")
}
> db.food.find({"fruit":"banana"})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }

$all연산자
2개이상의 요소가 일치하는 배열을 찾을 때
> db.food.insertOne({"fruit": ["apple","kumpuat","orange"]})
> db.food.insertOne({"fruit": ["cherry","banana","apple"]})
> db.food.find()
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }
{ "_id" : ObjectId("65829d39c6cb4f06e7cd2e88"), "fruit" : [ "apple", "kumpuat", "orange" ] }
{ "_id" : ObjectId("65829d47c6cb4f06e7cd2e89"), "fruit" : [ "cherry", "banana", "apple" ] }
> db.food.find({"fruit" : {"$all" : ["apple","banana"]}})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }
{ "_id" : ObjectId("65829d47c6cb4f06e7cd2e89"), "fruit" : [ "cherry", "banana", "apple" ] }

> db.food.find({"fruit": ["apple","banana","peach"]})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }

> db.food.find({"fruit": ["apple","banana"]})
일치 하는 것이 없다.
> db.food.find({"fruit": ["banana","apple","peach"]})
마찬가지
> db.food.find({"fruit": "peach"})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }

index가 2인 요소가 peach인것만
> db.food.find({"fruit.2": "peach"})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }


$size는 특정 크기의 배열을 쿼리하는 유용한 조건절
> db.food.find({"fruit": {"$size" : 3}})
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach" ] }
{ "_id" : ObjectId("65829d39c6cb4f06e7cd2e88"), "fruit" : [ "apple", "kumpuat", "orange" ] }
{ "_id" : ObjectId("65829d47c6cb4f06e7cd2e89"), "fruit" : [ "cherry", "banana", "apple" ] }

배열갱신
> var criteria = {"_id" : ObjectId("65829bfcc6cb4f06e7cd2e87")}
> db.food.update(criteria, {"$push" : {"fruit" : "strawberry"}}  )
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })

> db.food.update(criteria, {"$push" : {"fruit" : "strawberry"}, "$inc" : {"size" : 1}}  )
WriteResult({ "nMatched" : 1, "nUpserted" : 0, "nModified" : 1 })
> db.food.find()
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach", "strawberry", "strawberry" ], "size" : 1 }
{ "_id" : ObjectId("65829d39c6cb4f06e7cd2e88"), "fruit" : [ "apple", "kumpuat", "orange" ] }
{ "_id" : ObjectId("65829d47c6cb4f06e7cd2e89"), "fruit" : [ "cherry", "banana", "apple" ] }

> db.food.find({"size" : {"$gte" : 1}}))
{ "_id" : ObjectId("65829bfcc6cb4f06e7cd2e87"), "fruit" : [ "apple", "banana", "peach", "strawberry", "strawberry" ], "size" : 1 }

$slice연산자
find의 두 번째 매개변수에는 반환받을 키를 지정한다.
$slice연산자를 사용해서 배열 요소의 부분 집합을 반환받을 수 있다.

# comments를 2만 가지고 오기
> db.blog.findOne({"_id" : ObjectId("657a6c86add257455351ede9")}, {"comments" : {"$slice" : 2}})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "title" : "A blog post",
        "content" : "....",
        "comments" : [
                {
                        "comment" : "good post",
                        "auther" : "John",
                        "votes" : 0
                },
                {
                        "comment" : "i thougnt it was too short",
                        "auther" : "Clare",
                        "votes" : 3
                }
        ]
}

# 밑에서 2개만 가지고 오기
> db.blog.findOne({"_id" : ObjectId("657a6c86add257455351ede9")}, {"comments" : {"$slice" : -2}})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "title" : "A blog post",
        "content" : "....",
        "comments" : [
                {
                        "comment" : "free watches",
                        "auther" : "Alice",
                        "votes" : -5
                },
                {
                        "comment" : "vacation getways",
                        "auther" : "Lynn",
                        "votes" : -7
                }
        ]
}

# 2번까지 건너 뛰고 2개 가져오기
> db.blog.findOne({"_id" : ObjectId("657a6c86add257455351ede9")}, {"comments" : {"$slice" : [2, 2]}})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "title" : "A blog post",
        "content" : "....",
        "comments" : [
                {
                        "comment" : "free watches",
                        "auther" : "Alice",
                        "votes" : -5
                },
                {
                        "comment" : "vacation getways",
                        "auther" : "Lynn",
                        "votes" : -7
                }
        ]
}

#마지막 댓글 가져온다.
> db.blog.findOne({"_id" : ObjectId("657a6c86add257455351ede9")}, {"comments" : {"$slice" : -1}})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "title" : "A blog post",
        "content" : "....",
        "comments" : [
                {
                        "comment" : "vacation getways",
                        "auther" : "Lynn",
                        "votes" : -7
                }
        ]
}

#comments의 auther가 John의 댓글을 하나만
> db.blog.findOne({"comments.auther" :  "John" }, {"comments.$" : 1})
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "comments" : [
                {
                        "comment" : "good post",
                        "auther" : "John",
                        "votes" : 0
                }
        ]
}

> db.collectionName.insertOne({ 'x': 5 });
> db.collectionName.insertOne({ 'x': 15 });
> db.collectionName.insertOne({ 'x': 25 });
> db.collectionName.insertOne({ 'x': [5, 25]});
> db.collectionName.find();
{ "_id" : ObjectId("6583e9e038416d4181fc58b1"), "x" : 5 }
{ "_id" : ObjectId("6583e9e538416d4181fc58b2"), "x" : 15 }
{ "_id" : ObjectId("6583e9eb38416d4181fc58b3"), "x" : 25 }
{ "_id" : ObjectId("6583e9ef38416d4181fc58b4"), "x" : [ 5, 25 ] }

> db.collectionName.find({"x" : {"$gt" : 10, "$lt" : 20}});
{ "_id" : ObjectId("6583e9e538416d4181fc58b2"), "x" : 15 }
{ "_id" : ObjectId("6583e9ef38416d4181fc58b4"), "x" : [ 5, 25 ] }
5와 25는 둘 다 10과 20사이는 아니지만 25는 첫번째 절과 일치하고 (10보다 크다) 5는 두 번째 결과와 일치하기 때문(20보다 작다)에 반환된다.
이 방법은 배열에 대한 범위 쿼리가 슬모없어진다.
범위가 다중요소 배열과 일치하기 때문이다.

> db.collectionName.find({"x" : {"$elemMatch" : {"$gt" : 10, "$lt" : 20}}});
결과없음
{ "x" : 15 }는 배열이 아니므로 쿼리와 일티 하지 않음

> db.collectionName.insertOne({ 'x': [13, 18]});
> db.collectionName.find({"x" : {"$elemMatch" : {"$gt" : 10, "$lt" : 20}}});
{ "_id" : ObjectId("6583eca738416d4181fc58b5"), "x" : [ 13, 18 ] }
$elemMatch은 배열 요소에 대한 범위 쿼리에 유용



> db.people.insertOne({"name" : {"first" : "Joe" , "last" : "Schmoe"}, "age" : 45})
> db.people.find({"name" : {"first" : "Joe", "last" : "Schmoe"}})
{ "_id" : ObjectId("6583f1f738416d4181fc58b6"), "name" : { "first" : "Joe", "last" : "Schmoe" }, "age" : 45 }

내장 도큐먼트 쿼리를 할때는 가능하다면 특정키로 쿼리하는 방법이 좋다.
> db.people.find({"name.first" : "Joe", "name.last" : "Schmoe"})
{ "_id" : ObjectId("6583f1f738416d4181fc58b6"), "name" : { "first" : "Joe", "last" : "Schmoe" }, "age" : 45 }


> db.blog.find({"comments" : {"auther" : "Clare", "votes" : {"$lte" : 3}}})
결과가 없다
> db.blog.find({"comments.auther" : "Clare", "comments.votes" : {"$lte" : 3}})
{ "_id" : ObjectId("657a6c86add257455351ede9"), "title" : "A blog post", "content" : "....", "comments" : [ { "comment" : "good post", "auther" : "John", "votes" : 0 }, { "comment" : "i thougnt it was too short", "auther" : "Clare", "votes" : 3 }, { "comment" : "free watches", "auther" : "Alice", "votes" : -5 }, { "comment" : "vacation getways", "auther" : "Lynn", "votes" : -7 } ] }
> db.blog.find({"comments" : {"$elemMatch" : {"auther" : "John", "votes" : {"$lte": 3} }}})
{ "_id" : ObjectId("657a6c86add257455351ede9"), "title" : "A blog post", "content" : "....", "comments" : [ { "comment" : "good post", "auther" : "John", "votes" : 0 }, { "comment" : "i thougnt it was too short", "auther" : "Clare", "votes" : 3 }, { "comment" : "free watches", "auther" : "Alice", "votes" : -5 }, { "comment" : "vacation getways", "auther" : "Lynn", "votes" : -7 } ] }
>

# $where쿼리
도쿠먼트 내 두 키의 값을 비교하는 쿼리에 가장 자주 쓰인다.
두 필드 값이 동일 한 도쿠먼트를 반환받아보자. 

예를 들어 두 번째 도쿠먼트에서 "spinach"와  "watermelon"이 같은 값을 가진다. 몽고DB에서는 이런 경우 $조건절을 사용할 수 없으므로 "$where"절 내 자바스크립트로 처리한다.

db.foo.find({"$where" : function(){
  for(var current in this){
    for(var other in this){
      if(current != other && this[current] == this[current]){
        return true;
      }
    }
  }
  return false;
}})
{ "_id" : ObjectId("6584ca72100c7e7049a56fa9"), "apple" : 1, "banana" : 6, "peach" : 3 }
{ "_id" : ObjectId("6584caa4100c7e7049a56faa"), "apple" : 8, "spinach" : 4, "watermelon" : 4 }
함수가 true를 반환하면 해당 도큐먼트는 결과 셋에 포함되고 false를 반환하면 포함되지 않는다.

특정 값보다 큰 값 찾기:
db.collection.find({
  $where: function() {
    return this.fieldName > 10;
  }
})
문자열 길이가 특정 값보다 큰 문서 찾기:
db.collection.find({
  $where: function() {
    return this.stringField.length > 5;
  }
})

두 필드 값을 비교하여 찾기:
db.collection.find({
  $where: function() {
    return this.field1 > this.field2;
  }
})
특정 문자열을 포함하는 문서 찾기:

db.collection.find({
  $where: function() {
    return this.stringField.includes("example");
  }
})

커서
결과 개수를 제한하거나, 결과 중 몇개를 건너뛰거나, 여러개를 조절한 결과를 어떤 방향으로든 정렬하는 등 다양하게 조작할 수 있다.
> for (i = 0; i<100;i++){
... db.collection.insertOne({"x" : i})
... }
{
        "acknowledged" : true,
        "insertedId" : ObjectId("65854344100c7e7049a5700e")
}
> var cursor = db.collection.find()
> while (cursor.hasNext()){
    obj = cursor.next() 
    print(obj.x)
}
{ "_id" : ObjectId("65854344100c7e7049a5700e"), "x" : 99 }
 # cursor.hasNext()는 다음결과가 존재하는지 확인, cursor.next() 는 그결과를 가지고 온다.

> var cursor = db.people.find()
> cursor.forEach(function(x){ print(x.name) })
joe
joe
joe
[object BSON]

> var cursor = db.collection.find().sort({"x" : 1}).limit(1).skip(15)
> cursor.hasNext()
> var cursor = db.collection.find().limit(1).sort({"x" : 1}).skip(15)
> cursor.hasNext()
> var cursor = db.collection.find().skip(15).limit(1).sort({"x" : 1})
> cursor.hasNext()

# 제한과 건너 뛰기, 정렬
반환받는 개수를 제한하거나, 몇개의 결과를 건너뛰거나, 결과를 정렬
> db.collection.find().limit(3)
{ "_id" : ObjectId("65854344100c7e7049a56fab"), "x" : 0 }
{ "_id" : ObjectId("65854344100c7e7049a56fac"), "x" : 1 }
{ "_id" : ObjectId("65854344100c7e7049a56fad"), "x" : 2 }
> db.collection.find().skip(3)
{ "_id" : ObjectId("65854344100c7e7049a56fae"), "x" : 3 }
{ "_id" : ObjectId("65854344100c7e7049a56faf"), "x" : 4 }
{ "_id" : ObjectId("65854344100c7e7049a56fb0"), "x" : 5 }
{ "_id" : ObjectId("65854344100c7e7049a56fb1"), "x" : 6 }
{ "_id" : ObjectId("65854344100c7e7049a56fb2"), "x" : 7 }
{ "_id" : ObjectId("65854344100c7e7049a56fb3"), "x" : 8 }
{ "_id" : ObjectId("65854344100c7e7049a56fb4"), "x" : 9 }
{ "_id" : ObjectId("65854344100c7e7049a56fb5"), "x" : 10 }
{ "_id" : ObjectId("65854344100c7e7049a56fb6"), "x" : 11 }
{ "_id" : ObjectId("65854344100c7e7049a56fb7"), "x" : 12 }
{ "_id" : ObjectId("65854344100c7e7049a56fb8"), "x" : 13 }
{ "_id" : ObjectId("65854344100c7e7049a56fb9"), "x" : 14 }
{ "_id" : ObjectId("65854344100c7e7049a56fba"), "x" : 15 }
{ "_id" : ObjectId("65854344100c7e7049a56fbb"), "x" : 16 }
{ "_id" : ObjectId("65854344100c7e7049a56fbc"), "x" : 17 }
{ "_id" : ObjectId("65854344100c7e7049a56fbd"), "x" : 18 }
{ "_id" : ObjectId("65854344100c7e7049a56fbe"), "x" : 19 }
{ "_id" : ObjectId("65854344100c7e7049a56fbf"), "x" : 20 }
{ "_id" : ObjectId("65854344100c7e7049a56fc0"), "x" : 21 }
{ "_id" : ObjectId("65854344100c7e7049a56fc1"), "x" : 22 }

> db.people.find({"name": "joe"}).limit(2).sort({"age": -1 })
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7a"), "name" : "joe", "age" : 65 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49 }

> db.people.find({"name": "joe"}).limit(3).sort({"age": -1 }).skip(1)
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7c"), "name" : "joe", "age" : 49 }
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }
> db.people.find({"name": "joe"}).limit(3).sort({"age": -1 }).skip(2)
{ "_id" : ObjectId("4b2b9f67a1f631733d917a7b"), "name" : "joe", "age" : 20 }


인덱싱
for (i=0; i < 1000000 ; i++){
  db.test.insertOne({
    "i" : i,
    "username" : "user"+i,
    "age" : Math.floor(Math.random()*120),
    "created" : new Date()
  });
}

# explain함수를 이용해 쿼리ㅏ가 실행될 때 몽고DB가 무엇을 하는지 확인할 수 있다.
explain는 명령을 감사는 커서 보조자 메서드와 사용하면 좋다. 
explain커서 메서드는 다양한 CRUD작업의 실행 정보를 제공한다.
executionStats모드는 인덱스를 이용한 쿼리의 효과를 이해하는 데 도움이 된다. 
executionStats 필드의 값인 중첩된 도큐먼트를 살펴본다. 
totalDocsExamined 는 몽고DB가 쿼리를 실행하면서 살펴본 도큐먼트의 개수이다,.
"executionTimeMillis"는 0.4초걸렸다. 걸린 시간을 밀리초 단위로 보여준다.
"nReturned"는 반환받은 결과의 수를 보여준다. 단 한명이므로 값은 1이다.
db.test.find({"username" : "user101"}).explain("executionStats")
{
        "explainVersion" : "1",
        "queryPlanner" : {
                "namespace" : "admin.test",
                "indexFilterSet" : false,
                "parsedQuery" : {
                        "username" : {
                                "$eq" : "user101"
                        }
                },
                "maxIndexedOrSolutionsReached" : false,
                "maxIndexedAndSolutionsReached" : false,
                "maxScansToExplodeReached" : false,
                "winningPlan" : {
                        "stage" : "COLLSCAN",
                        "filter" : {
                                "username" : {
                                        "$eq" : "user101"
                                }
                        },
                        "direction" : "forward"
                },
                "rejectedPlans" : [ ]
        },
        "executionStats" : {
                "executionSuccess" : true,
                "nReturned" : 1,
                "executionTimeMillis" : 434,
                "totalKeysExamined" : 0,
                "totalDocsExamined" : 1000000,
                "executionStages" : {
                        "stage" : "COLLSCAN",
                        "filter" : {
                                "username" : {
                                        "$eq" : "user101"
                                }
                        },
                        "nReturned" : 1,
                        "executionTimeMillisEstimate" : 4,
                        "works" : 1000002,
                        "advanced" : 1,
                        "needTime" : 1000000,
                        "needYield" : 0,
                        "saveState" : 1000,
                        "restoreState" : 1000,
                        "isEOF" : 1,
                        "direction" : "forward",
                        "docsExamined" : 1000000
                }
        },
        "command" : {
                "find" : "test",
                "filter" : {
                        "username" : "user101"
                },
                "$db" : "admin"
        },
        "serverInfo" : {
                "host" : "DESKTOP-1PD96SS",
                "port" : 27017,
                "version" : "5.0.23",
                "gitVersion" : "3367195a14d0ba2734d2ba2719294fb974ad0834"
        },
        "serverParameters" : {
                "internalQueryFacetBufferSizeBytes" : 104857600,
                "internalQueryFacetMaxOutputDocSizeBytes" : 104857600,
                "internalLookupStageIntermediateDocumentMaxSizeBytes" : 104857600,
                "internalDocumentSourceGroupMaxMemoryBytes" : 104857600,
                "internalQueryMaxBlockingSortMemoryUsageBytes" : 104857600,
                "internalQueryProhibitBlockingMergeOnMongoS" : 0,
                "internalQueryMaxAddToSetBytes" : 104857600,
                "internalDocumentSourceSetWindowFieldsMaxMemoryBytes" : 104857600
        },
        "ok" : 1
}

인덱스를 만들려면 createIndex컬렉션 메서드를 사용한다.
> db.test.createIndex({"username" : 1})
{
        "numIndexesBefore" : 1,
        "numIndexesAfter" : 2,
        "createdCollectionAutomatically" : false,
        "ok" : 1
}
# db.test.find({"username" : "user101"}).explain("executionStats")를 실행시켜 진행률을 확인 해보자.
> db.test.find({"username" : "user999999"}).explain("executionStats")
쿼리 시간이 무척 빨라졌다. 
인덱싱된 필드를 변경하거나 쓰기 작업은 더 오래 걸린다.
변경할 때마다 도큐먼트뿐 아니라 모든 인덱스를 갱신해야 하기 때문이다.
그러므로 어떤 필드에 인덱싱하기에 적합한지 신중히 파악해야 한다.


# 복합 인덱스
쿼리를 할 때 index가 앞 부분에 놓일 때만 정렬에 도움이 된다.
> db.test.find().sort({"age" : 1, "username" : 1})
정렬 작업이 메모리 제한을 초과했음을 나타내는 것
인덱스 사용: 데이터베이스에 적절한 인덱스를 생성하여 쿼리 성능을 최적화할 수 있습니다.

> db.test.createIndex({"age" : 1, "username" : 1})
{
        "numIndexesBefore" : 2,
        "numIndexesAfter" : 3,
        "createdCollectionAutomatically" : false,
        "ok" : 1
}
이는 복합 인덱스라고 부른다. 쿼리에서 정렬 방향이 여러개이거나 검색 조건에 여러 개의 키가 있을 때 유용하다. 복합 인덱스는 2개 이상의 필드로 구성된 인덱스이다.


다시 실행해 보자
> db.test.find().sort({"age" : 1, "username" : 1})

> db.test.find({},{"_id" : 0 , "i" : 0, "created"  : 0})
{ "username" : "user0", "age" : 68 }
{ "username" : "user1", "age" : 76 }
{ "username" : "user2", "age" : 52 }
{ "username" : "user3", "age" : 107 }
{ "username" : "user4", "age" : 82 }
{ "username" : "user5", "age" : 37 }
{ "username" : "user6", "age" : 82 }
{ "username" : "user7", "age" : 68 }
{ "username" : "user8", "age" : 75 }
{ "username" : "user9", "age" : 12 }
{ "username" : "user10", "age" : 7 }
{ "username" : "user11", "age" : 92 }
{ "username" : "user12", "age" : 95 }
{ "username" : "user13", "age" : 80 }
{ "username" : "user14", "age" : 12 }
{ "username" : "user15", "age" : 101 }
{ "username" : "user16", "age" : 8 }
{ "username" : "user17", "age" : 54 }
{ "username" : "user18", "age" : 22 }
{ "username" : "user19", "age" : 114 }
age필드는 오름차순으로 정렬, 각나이에서 "username" 역시 오름차순으로 정렬된다,.

> db.test.find({"age" : 21}).sort({"username" : -1})
나이가 21과 일치하는 마지막 항목부터 순서대로 인덱스를 탐색

> db.test.find({"age" : {"$gte" : 21 , "$lte" : 30}})

> db.test.find({"age" : {"$gte" : 21 , "$lte" : 30}}).sort({"username" : 1})
다중 쿼리에 정렬도 포함. 이때 username은 정렬되지 않는다. 위 쿼리보다 비효율적이다.

> db.students.insertOne(
  {
    "_id": ObjectId('657a6c86add257455351ede9'),
    "student_id": 0,
    "scores": [
       { "type": 'exam', 
        "score": 38.0500000060199827 },
       { "type": 'quiz', 
        "score": 79.4507499500898700 },
       { "type": 'homework', 
        "score": 74.5015054869953400 },
       { "type": 'homework', 
        "score": 74.6838168461584500 }
    ],
    "class_id" : 127
  }
)
> db.students.findOne()
{
        "_id" : ObjectId("657a6c86add257455351ede9"),
        "student_id" : 0,
        "scores" : [
                {
                        "type" : "exam",
                        "score" : 38.050000006019985
                },
                {
                        "type" : "quiz",
                        "score" : 79.45074995008987
                },
                {
                        "type" : "homework",
                        "score" : 74.50150548699534
                },
                {
                        "type" : "homework",
                        "score" : 74.68381684615845
                }
        ],
        "class_id" : 127
}
> db.students.createIndex({"class_id" : 1})
{
        "numIndexesBefore" : 1,
        "numIndexesAfter" : 2,
        "createdCollectionAutomatically" : false,
        "ok" : 1
}
> db.students.createIndex({"student_id" : 1 , "class_id" : 1})
{
        "numIndexesBefore" : 2,
        "numIndexesAfter" : 3,
        "createdCollectionAutomatically" : false,
        "ok" : 1
}
> db.students.find({"student_id"  : {"$gt" : 500000}, "class_id" : 54  }).sort({"student_id" : 1}).explain("executionStats")
"totalKeysExamined"와 "nReturned"를 비교하면 몽고DB는 쿼리와 일치하는 도큐먼트를 찾으려고 얼마나 많은 인텍스를 통과 했는지 알 수 있다. 84만477개에서 9903개를 찾음.

쿼리를 충족시키는 인덱스가 선택적이지 않았음을 의미한다.
"executionTimeMillis"필드에 표시됐듯 쿼리를 실행하는데 4.3초가 넘게 걸린다.

쿼리의 인덱스에서 잘못된 부분을 파악해보자
"rejectedPlans" : [
                        {
                                "stage" : "SORT",
...
에서 "SORT"는 인덱스를 사용할 수 없어서 대신 인메모리 정렬을 한 것이다.
여기서 "student_id"가 50만보다 큰 레커드를 요청하므로 광범위한 "student_id"값을 지정한다. 이;는 컬렉션에 있는 절반 이상이다.

> db.students.find({"student_id"  : {"$gt" : 500000}, "class_id" : 54  }).sort({"student_id" : 1}).hint({"class_id" : 1}).explain("executionStats")
hint를 사용하지 않고 쿼리를 효율적으로 실행하는 방법을 생각해보자

"class_id" 와 "student_id"를 기반으로 하는 인덱스이다.
> db.students.createIndex({"class_id" : 1, "student_id" : 1 })
> db.students.find({"student_id"  : {"$gt" : 500000}, "class_id" : 54  }).sort({"student_id" : 1}).explain("executionStats")
# index를 사용하는 것을 알 수 있다.

> db.students.find({"student_id"  : {"$gt" : 500000}, "class_id" : 54  }).sort({final_grade : 1}).explain("executionStats")
# final_grade를 사용해도 먼저 보다는 빠르지만 인메모리를 사용하므로 위 예제보다 느리다.

인텍스는 적합한 인덱스를 찾는데 사용
동등 필터에 대한 키를 맨 앞에 표시해야 한다.
정렬에 사용되는 키는 다중값 필드 앞에 표시해야 한다.
다중값 필터에 대한 키는 마지막에 표시해야 한다,
{"a":1 , "b" : 1, "c" :1 ,...,"z" :1}이면 인덱스는 {"a":1}, {"a" :1 ,"b" :1}, {"a":1, "b":1,"c":1},...등의 인덱스를 가진다.
단, {"b" : 1}, {"a":1 , "c" :1 }에는 적용되지 않는다.

비효율적인 연산자
> db.test.find({"i" : {"$ne" : 3}})
$ne는 3이 아닌 모든 데이터를 가져와야 하므로 모두 조사해야 하므로 비효율 적이다.
$not을 사용하는 쿼리는 대부분 테이블 스캔을 한다.

> db.test.find({"age": 47, "username": {"$gt": "user5","$lt": "user8"}})
> db.test.find({"age": 47, "username": {"$gt": "user5","$lt": "user8"}}).explain("executionStats")
> db.test.find({"username": {"$gt": "user5","$lt": "user8"}, "age": 47})
> db.test.find({"username": {"$gt": "user5","$lt": "user8"}, "age": 47}).explain("executionStats")

#  or쿼리
> db.foo.createIndex({"apple" : 1})
> db.foo.createIndex({"banana" : 1})

현재 몽고DB는 하나의 쿼리에 하나의 index만 사용 할 수 있다. 
{"apple" : 1} 와 {"banana" : 1}의 두개의 INDEX가 있는 경우 {"apple" : 1, "banana" : 6 }으로 쿼리를 실행하면 생성된 인덱스 두개 중 하나만 사용한다.
> db.foo.find({"apple" : 1 , "banana" : 6 })

하지만 &or은 잘마다 하나씩의 인덱스를 사용한다.
> db.foo.find({"$or" : [{"apple" : 1}, {"banana" : 6 }]})
{ "_id" : ObjectId("6584ca72100c7e7049a56fa9"), "apple" : 1, "banana" : 6, "peach" : 3 }
> db.foo.find({"$or" : [{"apple" : 1}, {"banana" : 6 }]}).explain()

# 두번 쿼리해서 병합하는 것 보다는 한번쿼리하는 것이 좋다. 그런 경우 &or보다 &in이 더 좋다.
> db.foo.find({"apple": { "$in": [1, 8] }})


내장 도큐먼트 index
> db.students.find()
> db.students.createIndex({"scores.score" : 1})
서브도큐먼트를 쿼리 할때만 실행된다.

> db.students.find({"scores.score" : 79.45074995008987 })
> db.students.find({"scores.score" : 79.45074995008987 }).explain() 
# 위 코드는 index르ㅓㄹ 사용한다는 것을 알 수 있다..
> db.students.find( {"scores" : { "type" : "exam", "score" : 38.050000006019985 }})
> db.students.find( {"scores" : { "type" : "exam", "score" : 38.050000006019985 }}).explain()
# 하지만 위 코드는 index를 사용하지 않는다.



























